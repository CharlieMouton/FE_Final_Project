<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>FE final project by CharlieMouton</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/CharlieMouton/FE_Final_Project">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/CharlieMouton/FE_Final_Project/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/CharlieMouton/FE_Final_Project/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>FE final project</h1>
          <p></p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/CharlieMouton">CharlieMouton</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h3>
<a name="welcome-to-our-website" class="anchor" href="#welcome-to-our-website"><span class="octicon octicon-link"></span></a>Welcome to our website.</h3>

<p>Welcome to the FE_Final_Project website!</p>

<p>Collaborators: Julian Morris (<a href="https://github.com/jmorris1993" class="user-mention">@jmorris1993</a>), Charlie Mouton (<a href="https://github.com/CharlieMouton" class="user-mention">@CharlieMouton</a>), Jacob Riedel (<a href="https://github.com/jabb1123" class="user-mention">@jabb1123</a>), and David Zhu (<a href="https://github.com/hzhugit" class="user-mention">@hzhugit</a>).</p>

<p>The goal of this project is to create a turn-based strategy battle game similar to Fire Emblem and Final Fantasy Tactics. This project is the final assignment for Software Design, a programming course offered at Franklin W. Olin College of Engineering taught by Paul Ruvolo (<a href="https://github.com/pruvolo" class="user-mention">@pruvolo</a>).</p>

<h3>
<a name="proposal" class="anchor" href="#proposal"><span class="octicon octicon-link"></span></a>Proposal</h3>

<p>Our team, consisting of Julian Morris, Charlie Mouton, Jacob Riedel, and David Zhu, aim to create a turn-based strategy game akin to Fire Emblem and Final Fantasy Tactics. Our game will utilize a grid battlefield, and using basic stats such as attack, defense, critical chance, and dodge chance, characters will battle each other with the sole purpose of killing all opponents. Players will have control of each member of their team, and with the use of their environment and tactical maneuvering, they will attempt to kill all opponents. We will have a few different classes of units, including warrior, knight, and archer, each with their own strengths and weaknesses. Players will have to protect their weaker characters while dishing enough damage on their turn.</p>

<p>If things don't go as planned, our group will at least produce a top-down, two-player, gridded, simple battle scenario. Characters will have slightly randomized stats, and we will have at least three classes. The battlefield will have two or three terrain advantages, but nothing that fully blocks off sections of the field or interferes with combat interactions. We may download several sprites to represent the characters, but there won't be a visual theme to the game.</p>

<p>If things do go according to plan, however, we will have a 3d view of the field with lots of interactive terrain that may even swing the tides of battle. We will have more in-depth classes, with special abilities for each. The visuals of the game will be cohesive and add to the game, instead of detract from it. We may also add in objectives to the maps, or alternate ways to win. We would have multiple scenarios and maps, and possibly even have a "vs AI" option when two people aren't available to play. We may also add a store with items, so that we can have weapon interactions as well as potions and the like. One of the great things about this project is we have a lot of places we can go if we have time to improve at the end.</p>

<p>Our first step will be to design a basic character object, that has attributes for its battle stats (Attack,Defense,Critical Chance, Dodge Chance). We then will create a field layout where we can have two characters interact with each other. From here, we will start going more in depth on properties of the field and classes for the characters and then start making everything look good.</p>

<p>For our group, no one has too much experience for the visual side of things, so I think that is the area where we will struggle the most. We will have to be careful that we don't get so caught up in enhancing all other aspects of the game that the visual side will get left behind. We will be looking for ways to simplify the VIEW side of pygame while also maintaining a visually appealing game.</p>

<p>We are all excited to see what the product of this project will be, especially looking forward to the ways that we will shape this game into our own as we start to individualize from the Fire Emblem and Final Fantasy base that we will start with.</p>

<p>Thank you.</p>

<p>P.S. We are not collaborating with any other groups. We have no need for an angel adviser. We are not working across fields or with another course. Thanks again!</p>

<h3>
<a name="design-story" class="anchor" href="#design-story"><span class="octicon octicon-link"></span></a>Design Story</h3>

<p>Working on availabilities</p>

<p>An important part of creating the complete functionality of our game experience is to implement an algorithm that produces the locations where a character can access on the game field. This is easier said than done; there are a variety of factors that influence how we can implement the most effective algorithm. Some factors include:
Sorting through the whole map: This algorithm should mitigate its need to look through the whole map to produce which blocks are available to our current character. Because a character can move only a certain range, we feel that it’s ineffective to look at all blocks and determine whether or not the character can move to it.
Walls: Walls are direct obstacles for the characters, but they are placed directly above the grid. Therefore when considering movement, walls must not only prevent the character to walk into them, but they also must stop characters from walking through them.
Individual block effects: We are accounting for the fact that some blocks have limiting or special abilities. For instance, if we in the future want to implement a swamp or a teleportation block, we must be able to factor in and calculate the available block locations for all of those situations. Special blocks will impact how this algorithm functions directly as the game gets more complex.
Characters on blocks: Based on how our code is currently constructed, we made the intentional decision to keep characters and the grid blocks separate. Therefore, our algorithm must also consider where each character is in order to treat those characters as walls or allies when the time is appropriate.
Path History: Initial availabilities may be easy to generate, but later on it may be a challenge to work in another method that calculates the exactly path which the character took to get to its location. In the beginning, we plan to have the character teleport directly to a newly available location, but the act of moving to a location can be a major future challenge. 
Movement History: Similar to path history, our algorithm must have another set of memories that determine if a character can still move after an attack. However, the character would have already expended some movement, and this needs to be tracked so that eventually the character has an option to backtrack its actions.</p>

<p>Currently, our design plan has the following unique options:
We can produce all the area around our character: This appears to be the easiest and the closest stepping stone for producing a list of available locations. We can just use math to create an area that the character may have the range to reach. However, its easy implementation has a trade off with its ability to detect walls or special characters. Using this as our first iteration for range generation could potentially cause more challenges than necessary in the future. 
We can look through each individual block and determine its feasibility of movement in reference to the character: If we look at each individual block, we should not be able to miss a block that is not analyzed. Additionally, the block and the character interaction directly without any assumptions. This implementation can be extremely computationally intensive because our algorithm would have to be a qualifier that analyzes each block. Increase in the size of the game map would linearly make the search processes slower.
We can create a recursive function that branches out from the character’s original location: This method would aim to make the algorithm ‘grow’ from a character’s location. Like how a cell gets bigger and bigger, this algorithm would analyze the perimeter repeatedly for how many turns a character has. When it runs out of steps to branch, it should stop and produce a list of available locations. During the growth process, we can implement a recognizing method that determines whether a block is an obstacle or has special features. This algorithm could be much more difficult to implement because it may require buffers that can behave weirdly with walls. In terms of efficiency however, this method seems to make the most sense from a conceptual stance. 
We can implement Plan 1 and 2 together to remove scanned blocks that the player cannot move to: Alternatively we can generate all the moves that the character can reach first and then analyze how each block in that preliminary list relates to the character. At first, this proposition seems easy but with closer inspection we can see that this would take an algorithm that does two parts. More importantly, if there was a wall block relatively close to the character, the algorithm cannot determine how that wall can full impact all the locations that the character can go after the character expends its moves walking around the block.</p>

<p>From these considerations, our plan is to attempt strategy number 3. This may not be the easiest way to initially set up the algorithm, but hopefully by considering all unique scenarios this method will become successful. One of the biggest challenges that we need to overcome is calculating how ‘inhibitive’ a wall actually is. With the recursive growth method, we should be able to ‘grow’ around the walls rather than analyzing each independent block.</p>

<h3>
<a name="design" class="anchor" href="#design"><span class="octicon octicon-link"></span></a>Design</h3>

<p>Originally, our design started with the entirety of our code in one file. This was at the very beginning of the project, before we had more than 200 lines of code, and was useful to start looking at the big picture of what needed to happen. We quickly transitioned into having separate files for model, view, and controller, where we contained the main classes for each within the respective files. We worked under this structure for the first third of the project, but then during design reviews, a helpful ninja, Abe, suggested a different method of organization where model, view, and controller are each packages that we import into the main.py file. It was a lot of work to split up our three huge files into these folders, but it was a decision that we were all thought was great for organizing our code. It gave us a few issues at times, when we struggled to figure out where to store photo files that we were referencing, but ended up being able to store them in the model folder while referencing them in the view package. This allowed us to keep model and view completely separate.</p>

<p>As we continued to work on the project, we realized that our controller was doing a lot of things that model should be doing. This came about because we had multiclick commands, and did not originally have any idea how to do such a thing within model. We then realized that we could set up booleans in the model that determined which stage we were in for the controller. We then had to cut a lot of the stuff out of controller and put them in individual methods within model. This reorganizing was messy, and by the end of our design process, we had a code that although it was functional, it was relatively volatile, and when attempting to make changes or improvements to the game, bugs would come from all sides. This made making last minute improvements, such as adding movement animations, nearly impossible. By respecting the difference between model, view, and controller for the entirety of our design, we could have had much cleaner and less volatile code. </p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>