{"name":"FE final project","tagline":"","body":"### Welcome to our website.\r\nWelcome to the FE_Final_Project website!\r\n\r\nCollaborators: Julian Morris (@jmorris1993), Charlie Mouton (@CharlieMouton), Jacob Riedel (@jabb1123), and David Zhu (@hzhugit).\r\n\r\nThe goal of this project is to create a turn-based strategy battle game similar to Fire Emblem and Final Fantasy Tactics. This project is the final assignment for Software Design, a programming course offered at Franklin W. Olin College of Engineering taught by Paul Ruvolo (@pruvolo).\r\n\r\n### Proposal\r\nOur team, consisting of Julian Morris, Charlie Mouton, Jacob Riedel, and David Zhu, aim to create a turn-based strategy game akin to Fire Emblem and Final Fantasy Tactics. Our game will utilize a grid battlefield, and using basic stats such as attack, defense, critical chance, and dodge chance, characters will battle each other with the sole purpose of killing all opponents. Players will have control of each member of their team, and with the use of their environment and tactical maneuvering, they will attempt to kill all opponents. We will have a few different classes of units, including warrior, knight, and archer, each with their own strengths and weaknesses. Players will have to protect their weaker characters while dishing enough damage on their turn.\r\n\r\nIf things don't go as planned, our group will at least produce a top-down, two-player, gridded, simple battle scenario. Characters will have slightly randomized stats, and we will have at least three classes. The battlefield will have two or three terrain advantages, but nothing that fully blocks off sections of the field or interferes with combat interactions. We may download several sprites to represent the characters, but there won't be a visual theme to the game.\r\n\r\nIf things do go according to plan, however, we will have a 3d view of the field with lots of interactive terrain that may even swing the tides of battle. We will have more in-depth classes, with special abilities for each. The visuals of the game will be cohesive and add to the game, instead of detract from it. We may also add in objectives to the maps, or alternate ways to win. We would have multiple scenarios and maps, and possibly even have a \"vs AI\" option when two people aren't available to play. We may also add a store with items, so that we can have weapon interactions as well as potions and the like. One of the great things about this project is we have a lot of places we can go if we have time to improve at the end.\r\n\r\nOur first step will be to design a basic character object, that has attributes for its battle stats (Attack,Defense,Critical Chance, Dodge Chance). We then will create a field layout where we can have two characters interact with each other. From here, we will start going more in depth on properties of the field and classes for the characters and then start making everything look good.\r\n\r\nFor our group, no one has too much experience for the visual side of things, so I think that is the area where we will struggle the most. We will have to be careful that we don't get so caught up in enhancing all other aspects of the game that the visual side will get left behind. We will be looking for ways to simplify the VIEW side of pygame while also maintaining a visually appealing game.\r\n\r\nWe are all excited to see what the product of this project will be, especially looking forward to the ways that we will shape this game into our own as we start to individualize from the Fire Emblem and Final Fantasy base that we will start with.\r\n\r\nThank you.\r\n\r\nP.S. We are not collaborating with any other groups. We have no need for an angel adviser. We are not working across fields or with another course. Thanks again!\r\n\r\n### Final Report and Reflection\r\n\r\n\tLooking back at our original design proposal, it is interesting to see areas that we deemed less important and others that became more integral to our project. Our group was able to surpass our minimum deliverable, creating an isometric game with an interesting map and character interactions. Our maximum deliverable, while not fully defined, was not even remotely reached. We only were able to create one map, one end game scenario. Items and ‘world map’ gameplay was not able to be implemented. Even though we somewhat had a theme, we did not flesh out a storyline or dialogue at all. The majority of hard work for the project went into getting moving and move and attack ranges working properly. These tasks, though originally minor features to the game that we needed to move on to more complex things, soon began to bug out and become a major issue and major focus of our group. When we thought we had them working properly, adding more complexities to the game, such as barriers in the map or attempting to get animated walking, would open old wounds and we would have to start the process over again. These repeated, unexpected hurdles are what set our project back the most.\r\n\r\n  The design of our code went through several iterations and attempts to salvage poorly organized code. We originally started with one document containing all of our classes, but very quickly realized that that would not work well for us. We then considered having model, view, and controller and three separate files, but even that was very messy. We then found a way to organize things that had model, view, and controller as modules that we could import and behaved similarly to classes, and that is the design that we decided to stick with. Several times throughout the project, however, we realized that our MVC Structure was getting muddy, with controller and view doing some things that model was really in charge of and vice versa. We then attempted to clear cut the lines between each, and reorganize our code, but these constant reorganizations led to relatively volatile code by the end of the project. In the future, we would like to start with the MVC as folders initially, and better respect and recognize the role of each, while doing everything in our power to keep them isolated from each other.\r\n\r\nWe did a good job of working independently and integrating our individual tasks together. Our main issue in this area was that a lot of the time, merges were not happening with both members of the merge present. This caused some things to be left out, and confusion between the members of the team about what did what. It was not till closer to the end of the project that we decided to do more paired programming, where each person has knowledge of different parts of the integration, and together, they can ensure that neither side becomes dysfunctional and that all parts fit together in such a way that allows for clean work between them and easy connections to the system as a whole. Integration and paired programming earlier in the design process would have helped reduce confusion immensely later in the project.\r\n\r\n\tOn of the major bugs that we had to confront was our availabilities implementation, especially where other characters were involved. Some of these challenges were predicted when we came up with our choice for algorithm design, but we did not expect how difficult it was for the algorithm to meet all the requirements that it needed to hit. For instance, calculating the attack range when a character is present is more troublesome than just a simple view implementation. Initially when we want to calculate where the character can move and what the character’s attack range can reach, we used the same method for both. We created two buckets: one for movement and another for attack. However, our characters cannot move through enemy characters, but they must attack the enemy. Therefore, when our availabilities list grew, it could not consider what things can actually be attacked.\r\n\r\n\tWe tried to hack together some ways to work around this miscalculation, but no matter what we tried, movement and attack range still heavily influenced each other. To finally resolve this issue, we not only had to split this main algorithm into two somewhat identical methods, we also had to create a new method that had to calculate the perimeter of the first movement location results. By feeding in the perimeter blocks into the attack range method, we were finally able to allow attack range behavior like its supposed to.\r\n\r\nIn retrospect, attack range should never have been completely placed together with general availabilities. Some of the clunkiness in availabilities should be placed in their own smaller methods. If this were the case, attack and movement range could still share many commonalities without having to be messy and redundant. This has made us realize that programming architecture is very important to be hashed out before execution. Our original philosophy was to make code that worked and add on more working code. Without a strong foundation for a program, the whole project can seriously struggle with increasing complexity.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}