{"name":"FE final project","tagline":"","body":"### Welcome to our website.\r\nWelcome to the FE_Final_Project website!\r\n\r\nCollaborators: Julian Morris (@jmorris1993), Charlie Mouton (@CharlieMouton), Jacob Riedel (@jabb1123), and David Zhu (@hzhugit).\r\n\r\nThe goal of this project is to create a turn-based strategy battle game similar to Fire Emblem and Final Fantasy Tactics. This project is the final assignment for Software Design, a programming course offered at Franklin W. Olin College of Engineering taught by Paul Ruvolo (@pruvolo).\r\n\r\n### Proposal\r\nOur team, consisting of Julian Morris, Charlie Mouton, Jacob Riedel, and David Zhu, aim to create a turn-based strategy game akin to Fire Emblem and Final Fantasy Tactics. Our game will utilize a grid battlefield, and using basic stats such as attack, defense, critical chance, and dodge chance, characters will battle each other with the sole purpose of killing all opponents. Players will have control of each member of their team, and with the use of their environment and tactical maneuvering, they will attempt to kill all opponents. We will have a few different classes of units, including warrior, knight, and archer, each with their own strengths and weaknesses. Players will have to protect their weaker characters while dishing enough damage on their turn.\r\n\r\nIf things don't go as planned, our group will at least produce a top-down, two-player, gridded, simple battle scenario. Characters will have slightly randomized stats, and we will have at least three classes. The battlefield will have two or three terrain advantages, but nothing that fully blocks off sections of the field or interferes with combat interactions. We may download several sprites to represent the characters, but there won't be a visual theme to the game.\r\n\r\nIf things do go according to plan, however, we will have a 3d view of the field with lots of interactive terrain that may even swing the tides of battle. We will have more in-depth classes, with special abilities for each. The visuals of the game will be cohesive and add to the game, instead of detract from it. We may also add in objectives to the maps, or alternate ways to win. We would have multiple scenarios and maps, and possibly even have a \"vs AI\" option when two people aren't available to play. We may also add a store with items, so that we can have weapon interactions as well as potions and the like. One of the great things about this project is we have a lot of places we can go if we have time to improve at the end.\r\n\r\nOur first step will be to design a basic character object, that has attributes for its battle stats (Attack,Defense,Critical Chance, Dodge Chance). We then will create a field layout where we can have two characters interact with each other. From here, we will start going more in depth on properties of the field and classes for the characters and then start making everything look good.\r\n\r\nFor our group, no one has too much experience for the visual side of things, so I think that is the area where we will struggle the most. We will have to be careful that we don't get so caught up in enhancing all other aspects of the game that the visual side will get left behind. We will be looking for ways to simplify the VIEW side of pygame while also maintaining a visually appealing game.\r\n\r\nWe are all excited to see what the product of this project will be, especially looking forward to the ways that we will shape this game into our own as we start to individualize from the Fire Emblem and Final Fantasy base that we will start with.\r\n\r\nThank you.\r\n\r\nP.S. We are not collaborating with any other groups. We have no need for an angel adviser. We are not working across fields or with another course. Thanks again!\r\n\r\n### Design Story\r\n\r\nWorking on availabilities\r\n\r\nAn important part of creating the complete functionality of our game experience is to implement an algorithm that produces the locations where a character can access on the game field. This is easier said than done; there are a variety of factors that influence how we can implement the most effective algorithm. Some factors include:\r\nSorting through the whole map: This algorithm should mitigate its need to look through the whole map to produce which blocks are available to our current character. Because a character can move only a certain range, we feel that it’s ineffective to look at all blocks and determine whether or not the character can move to it.\r\nWalls: Walls are direct obstacles for the characters, but they are placed directly above the grid. Therefore when considering movement, walls must not only prevent the character to walk into them, but they also must stop characters from walking through them.\r\nIndividual block effects: We are accounting for the fact that some blocks have limiting or special abilities. For instance, if we in the future want to implement a swamp or a teleportation block, we must be able to factor in and calculate the available block locations for all of those situations. Special blocks will impact how this algorithm functions directly as the game gets more complex.\r\nCharacters on blocks: Based on how our code is currently constructed, we made the intentional decision to keep characters and the grid blocks separate. Therefore, our algorithm must also consider where each character is in order to treat those characters as walls or allies when the time is appropriate.\r\nPath History: Initial availabilities may be easy to generate, but later on it may be a challenge to work in another method that calculates the exactly path which the character took to get to its location. In the beginning, we plan to have the character teleport directly to a newly available location, but the act of moving to a location can be a major future challenge. \r\nMovement History: Similar to path history, our algorithm must have another set of memories that determine if a character can still move after an attack. However, the character would have already expended some movement, and this needs to be tracked so that eventually the character has an option to backtrack its actions.\r\n\r\nCurrently, our design plan has the following unique options:\r\nWe can produce all the area around our character: This appears to be the easiest and the closest stepping stone for producing a list of available locations. We can just use math to create an area that the character may have the range to reach. However, its easy implementation has a trade off with its ability to detect walls or special characters. Using this as our first iteration for range generation could potentially cause more challenges than necessary in the future. \r\nWe can look through each individual block and determine its feasibility of movement in reference to the character: If we look at each individual block, we should not be able to miss a block that is not analyzed. Additionally, the block and the character interaction directly without any assumptions. This implementation can be extremely computationally intensive because our algorithm would have to be a qualifier that analyzes each block. Increase in the size of the game map would linearly make the search processes slower.\r\nWe can create a recursive function that branches out from the character’s original location: This method would aim to make the algorithm ‘grow’ from a character’s location. Like how a cell gets bigger and bigger, this algorithm would analyze the perimeter repeatedly for how many turns a character has. When it runs out of steps to branch, it should stop and produce a list of available locations. During the growth process, we can implement a recognizing method that determines whether a block is an obstacle or has special features. This algorithm could be much more difficult to implement because it may require buffers that can behave weirdly with walls. In terms of efficiency however, this method seems to make the most sense from a conceptual stance. \r\nWe can implement Plan 1 and 2 together to remove scanned blocks that the player cannot move to: Alternatively we can generate all the moves that the character can reach first and then analyze how each block in that preliminary list relates to the character. At first, this proposition seems easy but with closer inspection we can see that this would take an algorithm that does two parts. More importantly, if there was a wall block relatively close to the character, the algorithm cannot determine how that wall can full impact all the locations that the character can go after the character expends its moves walking around the block.\r\n\r\nFrom these considerations, our plan is to attempt strategy number 3. This may not be the easiest way to initially set up the algorithm, but hopefully by considering all unique scenarios this method will become successful. One of the biggest challenges that we need to overcome is calculating how ‘inhibitive’ a wall actually is. With the recursive growth method, we should be able to ‘grow’ around the walls rather than analyzing each independent block.\r\n\r\n### Design\r\n\r\nOriginally, our design started with the entirety of our code in one file. This was at the very beginning of the project, before we had more than 200 lines of code, and was useful to start looking at the big picture of what needed to happen. We quickly transitioned into having separate files for model, view, and controller, where we contained the main classes for each within the respective files. We worked under this structure for the first third of the project, but then during design reviews, a helpful ninja, Abe, suggested a different method of organization where model, view, and controller are each packages that we import into the main.py file. It was a lot of work to split up our three huge files into these folders, but it was a decision that we were all thought was great for organizing our code. It gave us a few issues at times, when we struggled to figure out where to store photo files that we were referencing, but ended up being able to store them in the model folder while referencing them in the view package. This allowed us to keep model and view completely separate.\r\n\r\nAs we continued to work on the project, we realized that our controller was doing a lot of things that model should be doing. This came about because we had multiclick commands, and did not originally have any idea how to do such a thing within model. We then realized that we could set up booleans in the model that determined which stage we were in for the controller. We then had to cut a lot of the stuff out of controller and put them in individual methods within model. This reorganizing was messy, and by the end of our design process, we had a code that although it was functional, it was relatively volatile, and when attempting to make changes or improvements to the game, bugs would come from all sides. This made making last minute improvements, such as adding movement animations, nearly impossible. By respecting the difference between model, view, and controller for the entirety of our design, we could have had much cleaner and less volatile code. \r\n\r\n### Final Report and Reflection\r\n\r\n\tLooking back at our original design proposal, it is interesting to see areas that we deemed less important and others that became more integral to our project. Our group was able to surpass our minimum deliverable, creating an isometric game with an interesting map and character interactions. Our maximum deliverable, while not fully defined, was not even remotely reached. We only were able to create one map, one end game scenario. Items and ‘world map’ gameplay was not able to be implemented. Even though we somewhat had a theme, we did not flesh out a storyline or dialogue at all. The majority of hard work for the project went into getting moving and move and attack ranges working properly. These tasks, though originally minor features to the game that we needed to move on to more complex things, soon began to bug out and become a major issue and major focus of our group. When we thought we had them working properly, adding more complexities to the game, such as barriers in the map or attempting to get animated walking, would open old wounds and we would have to start the process over again. These repeated, unexpected hurdles are what set our project back the most.\r\n\r\n  The design of our code went through several iterations and attempts to salvage poorly organized code. We originally started with one document containing all of our classes, but very quickly realized that that would not work well for us. We then considered having model, view, and controller and three separate files, but even that was very messy. We then found a way to organize things that had model, view, and controller as modules that we could import and behaved similarly to classes, and that is the design that we decided to stick with. Several times throughout the project, however, we realized that our MVC Structure was getting muddy, with controller and view doing some things that model was really in charge of and vice versa. We then attempted to clear cut the lines between each, and reorganize our code, but these constant reorganizations led to relatively volatile code by the end of the project. In the future, we would like to start with the MVC as folders initially, and better respect and recognize the role of each, while doing everything in our power to keep them isolated from each other.\r\n\r\nWe did a good job of working independently and integrating our individual tasks together. Our main issue in this area was that a lot of the time, merges were not happening with both members of the merge present. This caused some things to be left out, and confusion between the members of the team about what did what. It was not till closer to the end of the project that we decided to do more paired programming, where each person has knowledge of different parts of the integration, and together, they can ensure that neither side becomes dysfunctional and that all parts fit together in such a way that allows for clean work between them and easy connections to the system as a whole. Integration and paired programming earlier in the design process would have helped reduce confusion immensely later in the project.\r\n\r\n\tOn of the major bugs that we had to confront was our availabilities implementation, especially where other characters were involved. Some of these challenges were predicted when we came up with our choice for algorithm design, but we did not expect how difficult it was for the algorithm to meet all the requirements that it needed to hit. For instance, calculating the attack range when a character is present is more troublesome than just a simple view implementation. Initially when we want to calculate where the character can move and what the character’s attack range can reach, we used the same method for both. We created two buckets: one for movement and another for attack. However, our characters cannot move through enemy characters, but they must attack the enemy. Therefore, when our availabilities list grew, it could not consider what things can actually be attacked.\r\n\r\n\tWe tried to hack together some ways to work around this miscalculation, but no matter what we tried, movement and attack range still heavily influenced each other. To finally resolve this issue, we not only had to split this main algorithm into two somewhat identical methods, we also had to create a new method that had to calculate the perimeter of the first movement location results. By feeding in the perimeter blocks into the attack range method, we were finally able to allow attack range behavior like its supposed to.\r\n\r\nIn retrospect, attack range should never have been completely placed together with general availabilities. Some of the clunkiness in availabilities should be placed in their own smaller methods. If this were the case, attack and movement range could still share many commonalities without having to be messy and redundant. This has made us realize that programming architecture is very important to be hashed out before execution. Our original philosophy was to make code that worked and add on more working code. Without a strong foundation for a program, the whole project can seriously struggle with increasing complexity.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}